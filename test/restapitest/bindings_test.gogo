	t.Run("Bindings from two enabled apps", func(t *testing.T) {
		testData := []bindingTestData{app1TestData, app2TestData}
		ctrl := gomock.NewController(t)
		proxy := newTestProxyForBindings(t, testData, ctrl)
		r := incoming.NewRequest(proxy.conf, utils.NewTestLogger(), nil)
		r.Log = utils.NewTestLogger()

		out, err := proxy.GetBindings(r, apps.Context{})
		require.NoError(t, err)

		EqualBindings(t, expectedCombined, out)
	})

	t.Run("Apps without granted locations doesn't get a request", func(t *testing.T) {
		app1TestData := app1TestData
		app1TestData.app.GrantedLocations = nil
		testData := []bindingTestData{app1TestData, app2TestData}

		ctrl := gomock.NewController(t)

		proxy := newTestProxyForBindings(t, testData, ctrl)
		r := incoming.NewRequest(proxy.conf, utils.NewTestLogger(), nil)
		r.Log = utils.NewTestLogger()

		out, err := proxy.GetBindings(r, apps.Context{})
		require.NoError(t, err)
		EqualBindings(t, expectedApp2Bindings, out)
	})

	t.Run("Disabled app doesn't get a request", func(t *testing.T) {
		d := app2TestData // clone
		d.app.Disabled = true
		testData := []bindingTestData{app1TestData, d}
		ctrl := gomock.NewController(t)

		proxy := newTestProxyForBindings(t, testData, ctrl)
		r := incoming.NewRequest(proxy.conf, utils.NewTestLogger(), nil)
		r.Log = utils.NewTestLogger()

		out, err := proxy.GetBindings(r, apps.Context{})
		require.NoError(t, err)
		EqualBindings(t, expectedApp1Bindings, out)
	})
}

func TestDuplicateCommand(t *testing.T) {
	testData := []bindingTestData{
		{
			app: apps.App{
				DeployType: apps.DeployBuiltin,
				Manifest: apps.Manifest{
					AppID:       apps.AppID("app1"),
					DisplayName: "App 1",
				},
				GrantedLocations: apps.Locations{
					apps.LocationCommand,
				},
			},
			bindings: []apps.Binding{
				{
					Location: apps.LocationCommand,
					Bindings: []apps.Binding{
						{
							Location:    "baseCommandLocation",
							Label:       "baseCommandLabel",
							Icon:        "base command icon",
							Hint:        "base command hint",
							Description: "base command description",
							Bindings: []apps.Binding{
								{
									Location: "sub1",
									Label:    "sub1",
									Icon:     "sub1 icon 1",
									Submit:   &apps.Call{Path: "/path"},
								},
								{
									Location: "sub1",
									Label:    "sub1",
									Icon:     "sub1 icon 2",
								},
								{
									Location: "",
									Label:    "",
									Icon:     "",
								},
							},
						},
					},
				},
				{
					Location: apps.LocationCommand,
					Bindings: []apps.Binding{
						{
							Location:    "",
							Label:       "",
							Icon:        "base2 command icon",
							Hint:        "base2 command hint",
							Description: "base2 command description",
						},
					},
				},
			},
		},
	}

	expected := []apps.Binding{
		{
			Location: apps.LocationCommand,
			Bindings: []apps.Binding{
				{
					AppID:       apps.AppID("app1"),
					Location:    "baseCommandLocation",
					Label:       "baseCommandLabel",
					Icon:        "https://test.mattermost.com/plugins/com.mattermost.apps/apps/app1/static/base command icon",
					Hint:        "base command hint",
					Description: "base command description",
					Bindings: []apps.Binding{
						{
							AppID:    apps.AppID("app1"),
							Location: "sub1",
							Label:    "sub1",
							Icon:     "https://test.mattermost.com/plugins/com.mattermost.apps/apps/app1/static/sub1 icon 1",
							Submit:   &apps.Call{Path: "/path"},
						},
					},
				},
			},
		},
	}

	ctrl := gomock.NewController(t)

	proxy := newTestProxyForBindings(t, testData, ctrl)
	r := incoming.NewRequest(proxy.conf, utils.NewTestLogger(), nil)
	r.Log = utils.NewTestLogger()
	out, err := proxy.GetBindings(r, apps.Context{})
	require.NoError(t, err)
	EqualBindings(t, expected, out)
}

func TestInvalidCommand(t *testing.T) {
	testData := []bindingTestData{
		{
			app: apps.App{
				DeployType: apps.DeployBuiltin,
				Manifest: apps.Manifest{
					AppID:       apps.AppID("app1"),
					DisplayName: "App 1",
				},
				GrantedLocations: apps.Locations{
					apps.LocationCommand,
				},
			},
			bindings: []apps.Binding{
				{
					Location: apps.LocationCommand,
					Bindings: []apps.Binding{
						{
							Location:    "baseCommandLocation",
							Label:       "baseCommandLabel",
							Icon:        "base command icon",
							Hint:        "base command hint",
							Description: "base command description",
							Bindings: []apps.Binding{
								{
									Location: "sub1",
									Label:    "sub1",
									Icon:     "sub1 icon 1",
									Submit:   &apps.Call{Path: "/path"},
								},
								{
									Location: "multiple word",
									Label:    "multiple word",
									Icon:     "sub1 icon 2",
								},
								{
									Location: "sub2",
									Label:    "multiple word",
									Icon:     "sub1 icon 1",
								},
							},
						},
					},
				},
			},
		},
	}

	expected := []apps.Binding{
		{
			Location: apps.LocationCommand,
			Bindings: []apps.Binding{
				{
					AppID:       apps.AppID("app1"),
					Location:    "baseCommandLocation",
					Label:       "baseCommandLabel",
					Icon:        "https://test.mattermost.com/plugins/com.mattermost.apps/apps/app1/static/base command icon",
					Hint:        "base command hint",
					Description: "base command description",
					Bindings: []apps.Binding{
						{
							AppID:    apps.AppID("app1"),
							Location: "sub1",
							Label:    "sub1",
							Icon:     "https://test.mattermost.com/plugins/com.mattermost.apps/apps/app1/static/sub1 icon 1",
							Submit:   &apps.Call{Path: "/path"},
						},
					},
				},
			},
		},
	}

	ctrl := gomock.NewController(t)

	proxy := newTestProxyForBindings(t, testData, ctrl)
	r := incoming.NewRequest(proxy.conf, utils.NewTestLogger(), nil)
	r.Log = utils.NewTestLogger()
	out, err := proxy.GetBindings(r, apps.Context{})
	require.NoError(t, err)
	EqualBindings(t, expected, out)
}


// EqualBindings asserts that two slices of bindings are equal ignoring the order of the elements.
// If there are duplicate elements, the number of appearances of each of them in both lists should match.
//
// EqualBindings calls t.Fail if the elements not match.
func EqualBindings(t *testing.T, expected, actual []apps.Binding) {
	opt := cmpopts.SortSlices(func(a apps.Binding, b apps.Binding) bool {
		return a.AppID < b.AppID
	})

	if diff := cmp.Diff(expected, actual, opt); diff != "" {
		t.Errorf("Bindings mismatch (-expected +actual):\n%s", diff)
	}
}

}
